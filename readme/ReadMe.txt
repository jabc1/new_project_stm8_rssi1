使用内部16M晶振
20181010
新建stm8l demo工程
20181013
1、测试定时器中断正常
2、添加工程文件
3、添加串口驱动==测试成功
4、内部16M晶振误差太大，导致波特率不准，9600bps可以。要想使用115200，就用外部晶振吧。
5、串口中断收发正常
6、无串口中断超时处理流程，以后添加
7、添加RTC代码，测试ok
/****************
配置RTC时钟源

RTC时钟源可选HSE，LSE，HSI或LSI。 
为确保RTC精确工作，要求系统时钟（SYSCLK）必须等于或大于4*RTCCLK值。如果系统时钟（SYSCLK）为LSE或LSI，则RTC时钟必须等于系统时钟（SYSCLK），并且禁用RTC同步机制（置位RTC_CR1寄存器RATIO位）。

配置RTC时钟源为LSE，1分频，即32768Hz。 
1. 等待CLK_CRTCR:RTCSWBSY位复位，然后设置CLK_CRTCR值为0x10； 
2. 等待CLK_ECKCR:LSERDY位置位，标识LSE时钟源已稳定可用； 
3. 等待CLK_ECKCR:LSEON位置位，标识LSE时钟源已启用。

配置ck_spre时钟：ck_spre时钟可用于日历和定时唤醒时钟。

ck_spre时钟，即1Hz时钟。 
1. 设置7位异步预分频，RTC_APREG:PREDIVA，默认127； 
2. 设置13（Medium）或15位同步预分频，RTC_SPRERx:PREDIV_S，默认255。

fCK_SPRE=fRTCCLK(PREDIV_S+1)(PREDIV_A+1)fCK_SPRE=fRTCCLK(PREDIV_S+1)(PREDIV_A+1)

 
解除RTC寄存器保护

执行以下操作顺序： 
1. 写0xCA到寄存器RTC_WPR; 
2. 写0x53到寄存器RTC_WPR。

写其它值到RTC_WPR，则自动激活RTC寄存器保护功能。

****************/

添加fifo缓存机制
测试fifo ok
添加看门狗
添加低功耗halt模式通过RTC定时唤醒测试ok
添加文件注释
工程运行一段时间会重启，不知道什么原因


20181121
添加查表执行功能

20181203
添加rf驱动程序，进行接收rf信号
20181218
说明单片机重要的两点
2,再来说说,堆(HEAP)的问题.

全局变量,静态变量,以及内存管理所用的内存,都是属于"堆"区,英文名:"HEAP"
与栈区不同,堆区,则从内存区域的起始地址,开始分配给各个全局变量和静态变量.
堆的生长方向,都是向上的.在程序里面,所有的内存分为:堆+栈. 只是他们各自的起始地址和增长方向不同,他们没有一个固定的界限,所以一旦堆栈冲突,系统就到了崩溃的时候了.
同样,我们用附件里面的例程测试:


stack_dir的地址是0X20000004,也就是STM32的内存起始端的地址.
这里本来应该是从0X2000 0000开始分配的,但是,我仿真发现0X2000 0000总是存放:0X2000 0398,这个值,貌似是MSP,但是又不变化,还请高手帮忙解释下.
其他的,全局变量,则依次递增,地址肯定大于0X20000004,比如cpu_endian的地址就是0X20000005.
这就是STM32内部堆的分配规则.

3,再说说,大小端的问题.
大端模式：低位字节存在高地址上，高位字节存在低地址上 
小端模式：高位字节存在高地址上，低位字节存在低地址上

STM32属于小端模式,简单的说,比如u32 temp=0X12345678;
假设temp地址在0X2000 0010.
那么在内存里面,存放就变成了:
地址              |            HEX         |
0X2000 0010  |  78   56   43  12  |

CPU到底是大端还是小端,可以通过如下代码测试:
//CPU大小端
//0,小端模式;1,大端模式.
static u8 cpu_endian;

//获取CPU大小端模式,结果保存在cpu_endian里面
void find_cpu_endian(void)
{ 
 int x=1;
 if(*(char*)&x==1)cpu_endian=0; //小端模式 
 else cpu_endian=1;    //大端模式  
}
以上测试,在STM32上,你会得到cpu_endian=0,也就是小端模式.





